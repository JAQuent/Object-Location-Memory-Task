---
title: 'Trial Generation: Code & reasoning'
author: "Joern Alexander Quent"
date: "17/05/2022"
output: html_document
---

```{r setup, include = FALSE, message = FALSE, warnings = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

# Libs
library(ggplot2)
library(latex2exp)
library(assortedRFunctions) #devtools::install_github("JAQuent/assortedRFunctions", upgrade = 'never')
library(knitr)
library(plyr)
```

# Aim
The main aim of this document is to generate the .csv file for the behavioural version of Object-Location Memory (OLM) Task. 


# Generating the object layout. 
The crucial difference between the fMRI version & the behavioural version is that the latter will feature random object location with the following constraints:

> The object locations were randomly chosen with the following constraints: they had to be at least 25 vm from the edge of the environment, at least 10 vm from the centre and at least 10 vm away from the nearest other object. Control trials were removed as they would serve no purpose in this version.

```{r find_object_locations}
# Set the seed
set.seed(20220516)

# Re-run
rerun <- TRUE

# Constraints & parameters
obj2edge   <- 25
obj2centre <- 10
obj2obj    <- 10
diameter   <- 180
numObjects <- 6
centre     <- data.frame(x = 0, y = 0)
steps      <- 1

# Draw circle for the edge
edge   <- circleFun(c(0, 0), diameter, npoints = 1000)

# Get min & max for uniform distribution
minValue = -(diameter/2 - obj2edge) 
maxValue = (diameter/2 - obj2edge)
# Because of the obj2edge constraint I don't even need to cover the full range of the environment

# Constraint function
isNotValid <- function(objLoc){
  # Object 2 edge constraint
  con1 <- c()
  for(i in 1:numObjects){
    # Temp bind
    tempBind <- rbind(objLoc[i, ], edge)
    
    # Remove row names
    row.names(tempBind) <- NULL
    
    # Calculate distances
    tempDistances <- as.matrix(dist(tempBind))
    
    
    con1[i] <- any(tempDistances[1, 2:nrow(tempDistances)] <= obj2edge)
  }
  # Aggregate with any
  con1 <- any(con1)
  
  # Object 2 centre constraint (also check that it is not outside the circle)
  tempDistances <- as.matrix(dist(rbind(centre, objLoc)))
  con2 <- any(tempDistances[1, 2:nrow(tempDistances)] <= obj2centre | tempDistances[1, 2:nrow(tempDistances)] > diameter/2)
  
  # Object 2 object constraint
  con3 <- any(dist(objLoc) <= obj2obj)
  
  

  return(any(con1, con2, con3))
}

# Run algorithm
if(rerun){
  # Randomly choose object locations
  objLoc <- data.frame(x = runif(numObjects, min = minValue, max = maxValue),
                       y = runif(numObjects, min = minValue, max = maxValue))
  
  # Check constraints
  while(isNotValid(objLoc)){
    # Sample again
    objLoc <- data.frame(x = runif(numObjects, min = minValue, max = maxValue),
                         y = runif(numObjects, min = minValue, max = maxValue))
    
    # Count steps
    steps = steps + 1
    #cat(paste0("\r", as.character(steps)))
  }
  
  # Save
  save.image("startlocation.RData")
} else {
  # Load the results
}
```


```{r plot_results, fig.height = 6, fig.width = 6.5}
# Add an object designation
objLoc$object <- as.character(1:6)


# Plot results
ggplot(objLoc, aes(x = x, y = y)) + 
  geom_point(aes(colour = object), size = 5) + 
  geom_path(data = edge, mapping = aes(x = x, y = y)) +
  labs(title = "Selected object layout following constraints", x = "Position on x", y = "Position on z")
```

# Random starting locations & heading angles
The behavioural version of the task will have 12 encoding trials (each object twice) and two blocks of retrieval trials with 30 trials each, which make the total trial number 72 trials. This means we need 72 random starting locations and heading angles. For the starting locations the constraints are that they have to be at least 20 vm away from the correct object and obviously they cannot be outside the circle. 

Here I re-purpose the algorithm from above to select 72 starting locations but first I create the trial order. As an added constraint, we don't want the same object to appear twice in a row. 

```{r create_trial_order}
# Seed
set.seed(20220517)

# Generate trial order
trialOrder <- rbind(objLoc[sample(rep(1:6, each = 2)),], 
                    objLoc[sample(rep(1:6, each = 5)),], 
                    objLoc[sample(rep(1:6, each = 5)),])

# Check if there are repetitions
while(max(rle(trialOrder$object)$length) > 1){
  # Generate trial order
  trialOrder <- rbind(objLoc[sample(rep(1:6, each = 2)),], 
                      objLoc[sample(rep(1:6, each = 5)),], 
                      objLoc[sample(rep(1:6, each = 5)),])
}

row.names(trialOrder) <- NULL

# Add auxiliary information
trialOrder$trial_num <- 1:72
trialOrder$block_num <- rep(1:3, times = c(12, 30, 30))
trialOrder$trialType <- rep(c('encoding', 'retrieval'), times = c(12, 60))
```

After creating the trial order, I can now find the object locations given the constraints. 

```{r starting_locations}
# Set the seed
set.seed(20220517)

# Re-run
rerun <- TRUE

# Constraints & parameters
start2edge <- 15
start2obj  <- 20
diameter   <- 180
numLoc     <- 72
centre     <- data.frame(x = 0, y = 0)
steps      <- 1

# Draw circle for the edge
edge   <- circleFun(c(0, 0), diameter, npoints = 1000)

# Get min & max for uniform distribution
minValue = -(diameter/2 - start2edge) 
maxValue = (diameter/2 - start2edge)
# Because of the start2edge constraint I don't even need to cover the full range of the environment

# Constraint function but now for each location individually
isNotValid <- function(startLoc, objLoc){
  # Start 2 edge constraint
  # Temp bind
  tempBind <- rbind(startLoc, edge)
    
  # Remove row names
  row.names(tempBind) <- NULL
    
  # Calculate distances
  tempDistances <- as.matrix(dist(tempBind))
  
  # Evaluate  
  con1 <- any(tempDistances[1, 2:nrow(tempDistances)] <= start2edge)
  
  
  # Check that it is not outside the circle)
  tempDistances <- as.matrix(dist(rbind(centre, startLoc)))
  con2 <- any(tempDistances[1, 2:nrow(tempDistances)] > diameter/2)
  
  # start 2 object constraint
  # Temp bind
  tempBind <- rbind(startLoc, objLoc)
    
  # Remove row names
  row.names(tempBind) <- NULL
    
  # Calculate distances
  tempDistances <- as.matrix(dist(tempBind))
    
    
  con3 <- any(tempDistances[1, 2:nrow(tempDistances)] <= start2obj)
  

  return(any(con1, con2, con3))
}

# Sample function
sampler <- function(){
  startLoc <- data.frame(x = runif(1, min = minValue, max = maxValue),
                         y = runif(1, min = minValue, max = maxValue))
  return(startLoc)
}


# Recursive function
recursiveFun <- function(steps, objLoc){
  # Print to console
  #cat(paste0("\rstep " , as.character(steps)))
  
  # Sample
  tempStartLoc <- sampler()
  
  # Check if valid if not do again
  if(!isNotValid(tempStartLoc, objLoc)){
    return(tempStartLoc)
  } else {
    steps <- steps + 1
    return(recursiveFun(steps, objLoc))
  }
}

# Run this recursive algorithm for all objects
startLoc <- data.frame(x = NULL, y = NULL)

for(i in 1:numLoc){
  steps <- 1
  
  startLoc <- rbind(startLoc, recursiveFun(steps, data.frame(x = trialOrder$x[i], y = trialOrder$y[i])))
}

# Add back to trialOrder
trialOrder$start_x <- startLoc$x
trialOrder$start_z <- startLoc$y
```

Now I can plot the distribution of objects and their associated start locations. 

```{r plot_results2.1, fig.height = 6, fig.width = 6.5}
# Plot results
ggplot(objLoc, aes(x = x, y = y)) + 
  geom_point(aes(colour = object), size = 5) + 
  geom_point(data = trialOrder, mapping = aes(x = start_x, y = start_z, colour = object), size = 3, shape = 3) +
  geom_path(data = edge, mapping = aes(x = x, y = y)) +
  labs(title = "Selected objects & start locations following constraints", x = "Position on x", y = "Position on z")
```

Or plotted for each object separately:

```{r plot_results2.2, fig.height = 4.5, fig.width = 6.5}
ggplot(objLoc, aes(x = x, y = y)) + 
  facet_wrap(~ object) +
  geom_point(aes(colour = object), size = 5) + 
  geom_point(data = trialOrder, mapping = aes(x = start_x, y = start_z, colour = object), size = 3, shape = 3) +
  geom_path(data = edge, mapping = aes(x = x, y = y)) +
  labs(title = "Selected objects & start locations following constraints", x = "Position on x", y = "Position on z")
```

In the last step, I examine the distributions of centrality for starting locations. An object is central if it is within 

```{r calc_circle_area}
# Area of the arena
radius1     <- diameter/2
areaCircle1 <- pi*radius1^2

# Area of the arena with half the radius
radius2 <- radius1/2
areaCircle2 <- pi*radius2^2

areaCentre <- areaCircle2
areaPeriphery <- areaCircle1 - areaCircle2
```

If the circles are split like this, then there are areas are very different.  

```{r show_cirlces, fig.height = 6, fig.width = 6}
# Draw circle for the edge
innerCircle   <- circleFun(c(0, 0), diameter/2, npoints = 1000)
outerCircle   <- edge

ggplot(outerCircle, aes(x = x, y = y)) + 
  geom_path() +
  geom_path(data = innerCircle, mapping = aes(x = x, y = y)) +
  labs(title = "Illustration of centre & periphery", x = "Position on x", y = "Position on z")
```

```{r calc_centrality}
# Temp bind centre and start locations
tempBind <- rbind(centre, data.frame(x = trialOrder$start_x, y = trialOrder$start_z))

# Calculate distances
distances <- as.matrix(dist(tempBind))[1, 2:nrow(tempBind)]

# Create & assign centrality value
trialOrder$start_centrality <- ifelse(distances >= radius1/2, 'perihery', 'central')
```

According to this calculation, the distribution of centrality for the starting locations is
```{r centrality_table}
kable(table(trialOrder$start_centrality))
```

This is not surprising as the area of the outer circle is larger and what we want to measure is centrality-avoidance in this task with this layout and not ground-truth-centrality-avoidance, so I think that should be no issue. 

# Generating the input .csv for the task

The .csv that is need for both the practice as well as the fMRI version of task needs entries the following columns: 

- _trial_num_ = Number of the trial (not strictly needed for UXF).
- _block_num_ = Number of the block (needed for UXF).
- _targets_	= The target given as the object number from 1 - 13 (see below how these numbers correspond to the object names).
- _targetNames_	= The name of the target.
- _start_x_	= Start location of the player.
- _start_z_	= Start location of the player.
- _start_yRotation_	= Start rotation of the player. 
- _object_x_	= Object location of the target. With the exception of control trials, this must be the same for all trials with the same target. 
- _object_z_	= Object location of the target. With the exception of control trials, this must be the same for all trials with the same target. 
- _cue_ = Period the cue is presented in seconds.
- _delay_	= Delay period after the cue was presented in seconds. 
- _ITI_	= ITI in seconds. 
- _trialType_	= Trial type i.e. standard or control trials using the gift as the object. 
- _speedForward_	= Forward speed in vm/s. 
- _rotationSpeed_	= Rotation speed in degrees/s.
- _start_centrality_ If start location is less than half the radius away from the centre, then it is central otherwise periphery. This not used by the unity. 
- _messageToDisplay_ = Integer indicating whether a messages should be displayed after the trial (yes if >= 0, no if -1). Numbers above -1 are used as the index of the message from the list. 

## The objects
```{r object_table, echo = FALSE}
tab1 <- data.frame(Object = c("Drum", "Basketball", "Pineapple", "Dice", "Cake", "Lamp", "Barrel", "Football", "Pawn", "Traffic cone", "Donut", "Vase", "Gift"),
                   Number = c(7, 2, 12, 5, 3, 10, 1, 8, 11, 4, 6, 13, 9),
                   Version = c(rep(c('Practice', 'Main task'), each = 6), 'control'))

kable(tab1)
```

## The seed for this randomisation
```{r seed}
set.seed(20220413)
```

## General task parameters
In the following are general parameters that are the same across all parts of the experiment. The initial orientation (i.e. heading direction) in each trial will be randomly selected from a uniform distribution from 0 to 360. 

```{r general_task_param}
speedForward  <- 15 # vm/s
rotationSpeed <- 50 # degrees/s
``` 

## Main task (grassy arena)
### Timings
Since this is a behavioural version, I did not jitter the timings. 

```{r mainTask_timings}
cuePeriod    <- 2 # seconds
delayPeriods <- 1.5 # seconds
ITIPeriods   <- 1.5 # seconds
```

### Find correct object names
```{r find_correct_object_names}
# Get only the main task object
mainTask_objects <- tab1[tab1$Version == "Main task",]

# Assign the temporary label from the trial order to it
mainTask_objects$tempNum <- 1:6

# Quickly loop through trialOrder
trialOrder$targets <- NA
trialOrder$targetNames <- NA

for(i in 1:nrow(trialOrder)){
  trialOrder$targets[i]     <- mainTask_objects$Number[as.numeric(trialOrder[i, 'object'])]
  trialOrder$targetNames[i] <- mainTask_objects$Object[as.numeric(trialOrder[i, 'object'])]
}
```

### Create the .csv file
```{r mainTask_csv_file}
# Adding to one DF
mainTask <- data.frame(trial_num = trialOrder$trial_num,
                       block_num = trialOrder$block_num,
                       targets = trialOrder$targets,
                       targetNames= trialOrder$targetNames,
                       start_x = trialOrder$start_x,
                       start_z = trialOrder$start_z,
                       object_x = trialOrder$x,
                       object_z = trialOrder$y,
                       cue = cuePeriod,
                       delay = delayPeriods,
                       ITI = ITIPeriods,
                       trialType = trialOrder$trialType,
                       speedForward = speedForward,
                       rotationSpeed = rotationSpeed,
                       messageToDisplay = -1)

# Sample start locations from uniform distribution
mainTask$start_yRotation <- runif(n = nrow(mainTask), min = 0, max = 360)


# Add a messages after the runs
mainTask[12, 'messageToDisplay']  <- 0 # Before retrieval
mainTask[42, 'messageToDisplay']  <- 1 # Waiting message 

# Write .csv file
write.csv(x = mainTask, file = 'mainTask_behavioural.csv', quote = FALSE, row.names = FALSE)
```
